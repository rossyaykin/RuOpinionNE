def parse_data(jsonl_filepath):
    """ Parse competition data.
    """

    def __iter_parsed_json_lines(filepath):
        with open(filepath, 'r', encoding='utf-8') as infile:
            for line in infile.readlines():
                yield json.loads(line)

    # Return list of parsed lines, presented in a form of dictionaries.
    return list(__iter_parsed_json_lines(filepath=jsonl_filepath))


def to_jsonl(data, target):
    """takes a list of dicts and path;
    saves the list to jsonl"""

    with open(target, "w") as f:
        for item in data:
            f.write(f"{json.dumps(item, ensure_ascii=False)}\n")


def save_jsonl(dataframe, path):
    """similar to to_jsonl but adds .jsonl to the path"""
    path+='.jsonl'
    return to_jsonl(dataframe, path)

def dict2tuple(entry):
    """takes a single dataset entry (dict)
    and return a pair (text, opinion tuples)
    where opinion tuples is a list of lists"""

    if len(entry['opinions']) == 0:
        return (entry['text'], [])
    opinions = list()
    for elem in entry['opinions']:
        opinions.append([elem['Source'][0][0], elem['Target'][0][0], elem['Polar_expression'][0][0], elem['Polarity']])
    return (entry['text'], opinions)

def extract_tuple(text):
    """takes a text and tries to extract opinion tuples from it;
    returns opinion tuples as a list of lists;
    the text is supposed to be generated by a model"""

    if isinstance(text, list):
        return text
    lines = text.split('\n')
    for elem in lines:
        if len(elem.strip()) > 0 and elem.strip()[0] == '[' and ']' in elem:
            curr = elem.strip()
            while curr[-1] != ']':
                curr = curr[:-1]
            return curr
    return '[]'

def df2structure(df_pred):
    """takes a dataframe which has to contain the
    following columns: 'sent_id', 'text', 'pred';
    preds must be:
    (i) a list of lists OR
    (ii) a string which can be evaluated as a list of lists;
    returns a list of dicts
    which can be saved to .jsonl and submitted"""

    preds = list()
    for i, row in df_pred.iterrows():
        opinions = list()
        if isinstance(row['pred'], float):
            preds.append({'sent_id': row['sent_id'], 'text': row['text'], 'opinions': opinions})
            continue
        elif isinstance(row['pred'], str):
            curr = ast.literal_eval(row['pred'])
        else:
            curr = row['pred']
        for elem in curr:
            # holder
            try:
                h_ind = row['text'].index(elem[0])
                h_ind = f'{h_ind}:{h_ind+len(elem[0])}'
            except (ValueError, IndexError, TypeError):
                if elem[0] == 'NULL':
                    h_ind = '0:0'
                else:
                    h_ind = 'NULL'
            # target
            try:
                t_ind = row['text'].index(elem[1])
                t_ind = f'{t_ind}:{t_ind+len(elem[1])}'
            except (ValueError, IndexError, TypeError):
                t_ind = '0:0'
            # expression
            try:
                e_ind = row['text'].index(elem[2])
                e_ind = f'{e_ind}:{e_ind+len(elem[2])}'
            except (ValueError, IndexError, TypeError):
                e_ind = '0:0'
            # polarity
            try:
                if elem[3] in ('POS', 'NEG'):
                    pol = elem[3]
                else:
                    pol = 'NEG'
            except IndexError:
                pol = 'NEG'
            # append result
            if len(elem) == 4:
                opinions.append({'Source':[[elem[0]], [h_ind]], 'Target':[[elem[1]], [t_ind]],
                             'Polar_expression':[[elem[2]], [e_ind]], 'Polarity':pol})
            elif len(elem) == 3:
                opinions.append({'Source':[[elem[0]], [h_ind]], 'Target':[[elem[1]], [t_ind]],
                             'Polar_expression':[['0'], ['0:0']], 'Polarity':pol})
        result = {'sent_id': row['sent_id'], 'text': row['text'], 'opinions': opinions}
        try:
            convert_opinion_to_tuple(result) # check for errors
            preds.append(result)
        except Exception:
            preds.append({'sent_id': row['sent_id'], 'text': row['text'], 'opinions': []})
        # preds.append({'sent_id': row['sent_id'], 'text': row['text'], 'opinions': opinions})
    return preds

def str2list(text):
    """tries to evaluate a string as a list;
    doesn't change lists;
    returns None if fails"""
    if isinstance(text, list):
        return text
    try:
        res = ast.literal_eval(text)
    except (SyntaxError, ValueError):
        res = None
    return res

def form_prompt(examples, text):
    """takes a list of example pairs (text, opinion tuples),
    where opinion tuples is a list of lists,
    and a single target text;
    returns a prompt with shots taken from example pairs
    and ending with a target text"""

    shots = '\n'.join([f'Текст: {pair[0]}\nОтвет: {pair[1]}' for pair in examples])
    return f"""Ты эксперт в оценке тональности.
Тебе нужно найти все негативные и позитивные отношения между сущностями в тексте и вывести их в следующем формате:
[источник отношения, объект отношения, выражение в тексте содержащее оценку, оценка (POS/NEG)]
Если источником отношения является автор, то пиши:
['AUTHOR', объект отношения, выражение в тексте содержащее оценку, оценка (POS/NEG)]
Если выраженного источника нет, то пиши:
['NULL', объект отношения, выражение в тексте содержащее оценку, оценка (POS/NEG)]
Допустимо вернуть пустой ответ:
[]
Не нужно давать пояснений к ответу.
Примеры
{shots}
Текст: {text}
Ответ: """

def short_report(dataframe):
    """takes a dataframe which has to contain the
    following columns: 'target', 'pred';
    counts and prints:
    (i) exact mathces between target and pred;
    (ii) accuracy;
    (iii) number of NaNs in pred
    does not return anything"""

    count = sum([row['target'] == row['pred'] for i, row in dataframe.iterrows()])
    print(f"Count: {count}")
    print(f"Accuracy: {count/len(dataframe):.3f}")
    print(f"NaNs: {dataframe.isna().sum()['pred']}")
